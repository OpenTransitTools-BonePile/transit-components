{"version":3,"sources":["VehicleGeometry.js"],"names":["tiUrl","geojson","Number","prototype","round","places","Math","VehicleGeometry","patterns","nextProps","pat","key","geom","points","pts","polyline","decode","revCoords","coordinates","c","push","reverse","vehicle","a","agencyId","p","shapeId","ap","d","Date","now","getAgencyPattern","retVal","heading","geomWsUrl","getUrl","console","log","fetch","then","res","json","indexOf","cachePatternGeojson","cachePatternEncoded","catch","error","lat","lon","found","bestLat","bestLon","closeLat","closeLon","i","length","x","abs","y","isNorthbound","isSouthbound","callGeometryWS","geomGray","geomColor","mid","stopSequence","findPointOnLine","geometry","props","trackedVehicle","pattern","getGeometry","gray","color","segments","MapLayer"],"mappings":"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","sourcesContent":["import React from 'react';\nimport { FeatureGroup, MapLayer, Polyline } from 'react-leaflet';\nimport polyline from '@mapbox/polyline';\n\n// const tiUrl = \"https://maps.trimet.org/otp_mod/index\";\n// const tiUrl = \"http://localhost:54445/ti\";\n//const tiUrl = \"https://maps7.trimet.org/ti/index\";\nconst tiUrl = \"https://betaplanner.trimet.org/ws/ti/v0/index\";\n\n//const geojson = \"\";  // use this setting if want to use encoded vs. geojson\nconst geojson = \"/geojson\";\n\n\nNumber.prototype.round = function(places) {\n  return +(Math.round(this + \"e+\" + places)  + \"e-\" + places);\n}\n\nclass VehicleGeometry extends MapLayer {\n  patterns = [];\n\n  componentDidMount() {}\n  componentWillUnmount() {}\n  componentWillReceiveProps(nextProps) {}\n  createLeafletElement() {}\n  updateLeafletElement() {}\n\n  cachePatternEncoded(pat, key) {\n    let geom = pat.points;\n    const pts = polyline.decode(geom);\n    this.patterns[key] = pts;\n  }\n\n  cachePatternGeojson(pat, key) {\n    /**\n     * will cache the [[lat,lon], [lat,lon], etc...] coords\n     * note: geojson uses [lon,lat] (e.g., [X, Y], so must reverse that to match encoded coords\n     */\n    let revCoords = [];\n    for(const c of pat.coordinates)\n      revCoords.push(c.reverse())\n    this.patterns[key] = revCoords;\n  }\n\n  getAgencyPattern(vehicle) {\n    const a = vehicle.agencyId || \"TriMet\";\n    const p = vehicle.shapeId;\n    return `${a}:${p}`;\n  }\n\n  getUrl(vehicle, ap) {\n    const d = Date.now();\n    if(!ap)\n      ap = this.getAgencyPattern(vehicle);\n\n    let retVal = `${tiUrl}/patterns/${ap}/geometry${geojson}?date=${d}`;\n    return retVal\n  }\n\n  isNorthbound(vehicle) {\n    return (vehicle.heading <= 45.0 || vehicle.heading >= 315.0);\n  }\n  isSouthbound(vehicle) {\n    return (vehicle.heading >= 135.0 && vehicle.heading <= 225.0);\n  }\n  isEastbound(vehicle) {\n    return (vehicle.heading > 45.0 && vehicle.heading < 135.0);\n  }\n  isWestbound(vehicle) {\n    return (vehicle.heading > 225.0 && vehicle.heading < 315.0);\n  }\n\n  callGeometryWS(vehicle) {\n    // https://maps.trimet.org/otp_mod/index/patterns/TriMet:190:0:04/geometry\n    let retVal = null;\n\n    const ap = this.getAgencyPattern(vehicle);\n    let geomWsUrl = this.getUrl(vehicle, ap);\n\n    console.log(\"Calling GEO URL: \" + geomWsUrl);\n    fetch(geomWsUrl)\n    .then(res => {\n      retVal = res.json();\n      return retVal;\n    })\n    .then(json => {\n      if(geomWsUrl.indexOf('geojson') >= 0)\n        this.cachePatternGeojson(json, ap);\n      else\n        this.cachePatternEncoded(json, ap);\n    })\n    .catch(error => {\n      console.log(\"VEH GEOMETRY fetch() error: \" + error);\n    });\n    return retVal;\n  }\n\n  findPointOnLine(vehicle, geom) {\n    /** brute-force find a vertex in the line geometry near the vehicle's position\n     *  a bit hacky line intersection uses rounding points to N decimal places (rough find)\n     *  and then looking for the nearest lat / lon in that subset of points\n     */\n    let retVal = 0;\n\n    // step 1: round our vehicle position to 2 decimal 'places'\n    let places = 2;\n    let lat = vehicle.lat.round(places);\n    let lon = vehicle.lon.round(places);\n\n    // step 2: bunch of variables for finding the best split point of the line to the vehicle\n    let found = 0;\n    let bestLat = -1;\n    let bestLon = -1;\n    let closeLat = 111.111;\n    let closeLon = 111.111;\n\n    // step 3: loop thru the whole line (probably a better / quick sort way to do this, but...)\n    for(let i = 0; i < geom.length; i++) {\n\n      // step 4: find a rough set of points in the line that are near the vehicle position (2 decimal places)\n      if(geom[i][0].round(places) === lat && geom[i][1].round(places) === lon) {\n        found = i;\n\n        // step 5: find the closest lat & lon within this sub-set of rough split points\n        let x = Math.abs(geom[i][1] - vehicle.lon);\n        if(x < closeLon) {\n          bestLon = i;\n          closeLon = x;\n        }\n\n        let y = Math.abs(geom[i][0] - vehicle.lat);\n        if(y < closeLat) {\n          bestLat = i;\n          closeLat = y;\n        }\n\n        // step 6: continue the loop here to collect all rough (2 decimal places) split points\n        continue;\n      }\n\n      // step 6b: we found pattern split points above, so let's exit line traversal here\n      if(found > 0)\n        break;\n    }\n\n    // step 7: have we 'found' any candidate line split points from looping thru the line ?\n    if(found > 0) {\n      retVal = found;  // if so, let's use that rough index as a split-point\n\n      // step 8: let's see if there's a better split point from step #5 above to use over 'found'\n      //         note: we'll occasionally use the vehicle's heading to chose the best split point\n      if(bestLat >= 0 && bestLon >= 0) {\n        if(bestLat === bestLon)\n          retVal = bestLat;\n        else if(this.isNorthbound(vehicle) || this.isSouthbound(vehicle))\n          retVal = bestLat;\n        else\n          retVal = bestLon;\n      }\n    }\n\n    return retVal;\n  }\n\n  getGeometry(vehicle) {\n    /**\n     * find the vehicle's pattern, either in cache or via the pattern service (which is not request/\n     * /response, thus might not come back in this call)\n     */\n    let retVal = null;\n\n    // step 1: get the geometry (either from cache or by calling the pattern service)\n    const key = this.getAgencyPattern(vehicle);\n    let geom = this.patterns[key];\n    if(!geom) {\n      this.callGeometryWS(vehicle);\n      geom = this.patterns[key];\n    }\n\n    // step 2: if we have a line geometry, let's break it in 2 at the vehicle location\n    if(geom) {\n      let geomGray = [];\n      let geomColor = [];\n      let mid = 0;\n\n      if(vehicle.stopSequence === 1)\n        mid = 0;\n      else\n        mid = this.findPointOnLine(vehicle, geom);\n\n      for(let i = 0; i < geom.length; i++) {\n        if(i <= mid)\n          geomGray.push(geom[i]);\n        if(i >= mid)\n          geomColor.push(geom[i]);\n      }\n      retVal = [\n        {key: key + \"-PAST\", geometry: geomGray},\n        {key: key + \"-FUTURE\", geometry: geomColor},\n      ];\n\n    }\n\n    return retVal;\n  }\n\n  render () {\n    const vehicle = this.props.trackedVehicle;\n    if(!vehicle)\n      return <FeatureGroup />;\n\n    let pattern = this.getGeometry(vehicle);\n    if(!pattern)\n      return <FeatureGroup />;\n\n    console.log(\"drawing...\")\n\n    const gray = '#555555';\n    const color = '#00bfff';\n    const segments = [];\n    segments.push(\n      <Polyline\n        key={pattern[0].key}\n        positions={pattern[0].geometry}\n        weight={4}\n        color={gray}\n        opacity={0.8}\n      />\n    );\n    segments.push(\n      <Polyline\n        key={pattern[1].key}\n        positions={pattern[1].geometry}\n        weight={4}\n        color={color}\n        opacity={0.8}\n      />\n    );\n\n    return segments.length > 0\n      ? <FeatureGroup><div>{segments}</div></FeatureGroup>\n      : <FeatureGroup />;\n  }\n}\n\nexport default VehicleGeometry;\n"]}